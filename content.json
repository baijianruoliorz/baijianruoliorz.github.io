{"meta":{"title":"Blog-WIZZBEWINTERCAMP","subtitle":"为之2021BE冬令营","description":"just a gopher","author":"baijianruoliorz","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"JavaSe-03","slug":"wizz-WinterCamp JavaSe-03","date":"2021-01-14T15:52:40.065Z","updated":"2021-01-14T15:53:20.333Z","comments":true,"path":"2021/01/14/wizz-WinterCamp JavaSe-03/","link":"","permalink":"http://example.com/2021/01/14/wizz-WinterCamp%20JavaSe-03/","excerpt":"","text":"集合框架总结ArrayList因为集合相对重要 这里罗列一些常用的API add 1234567891011121314151617package collection;import java.util.ArrayList;public class TestCollection &#123; public static void main(String[] args) &#123; ArrayList ls=new ArrayList(); // 把5个对象加入到ArrayList中 for (int i = 0; i &lt; 5; i++) &#123; ls.add(i); &#125; // 在指定位置增加对象 ls.add(3, i); System.out.println(ls); &#125;&#125; contains 判断一个对象是否存在与list中 比如 我先创建了一个对象 叫CzrOrz 123456789101112131415161718192021222324package charactor;public class CzrOrz &#123; public String name; public float hp; public int damage; public CzrOrz() &#123; &#125; // 增加一个初始化name的构造方法 public CzrOrz(String name) &#123; this.name = name; &#125; // 重写toString方法 public String toString() &#123; return name; &#125;&#125; 123456789101112131415161718192021222324252627package collection;import java.util.ArrayList;import charactor.CzrOrz;public class TestCollection &#123; public static void main(String[] args) &#123; ArrayList czrs = new ArrayList(); // 初始化5个对象 for (int i = 0; i &lt; 5; i++) &#123; czrs.add(new CzrOrz(&quot;CzrOrz &quot; + i)); &#125; CzrOrz specialCzrOrz = new CzrOrz(&quot;special czr&quot;); czrs.add(specialCzrOrz); System.out.println(czrs); // 判断一个对象是否在容器中 // 判断标准： 是否是同一个对象，而不是name是否相同 System.out.print(&quot;虽然一个新的对象名字也叫 czr 1，但是contains的返回是:&quot;); System.out.println(heros.contains(new Hero(&quot;czr 1&quot;))); System.out.print(&quot;而对specialCzrOrz的判断，contains的返回是:&quot;); System.out.println(heros.contains(specialCzrOrz)); &#125;&#125; 以上code大家可以写一份自己的 康康运行结果如何. get 获取指定位置的对象 12345678910111213141516171819202122232425package collection;import java.util.ArrayList;import charactor.CzrOrz;public class TestCollection &#123; public static void main(String[] args) &#123; ArrayList czrs = new ArrayList(); // 初始化5个对象 for (int i = 0; i &lt; 5; i++) &#123; czrs.add(new CzrOrz(&quot;czr &quot; + i)); &#125; CzrOrz specialczr = new Czr(&quot;special czr&quot;); czrs.add(specialczr); //获取指定位置的对象 System.out.println(czrs.get(5)); //如果超出了范围，依然会报错 System.out.println(czrs.get(6)); &#125;&#125; remove 删除指定位置的对象 1234567891011121314151617181920212223242526272829package collection;import java.util.ArrayList;import charactor.CzrOrz;public class TestCollection &#123; public static void main(String[] args) &#123; ArrayList czrs = new ArrayList(); // 初始化5个对象 for (int i = 0; i &lt; 5; i++) &#123; czrs.add(new CzrOrz(&quot;czr &quot; + i)); &#125; CzrOrz specialczr = new Czr(&quot;special czr&quot;); czrs.add(specialczr); //获取指定位置的对象 System.out.println(czrs.get(5)); //如果超出了范围，依然会报错 System.out.println(czrs.get(6)); czrs.remove(2); System.out.println(&quot;删除下标是2的对象&quot;); &#125;&#125; 其他API 还有set size toArray ,为了控制篇幅长度以及调动大家搜索能力 这里就当一个作业交给大家自己搜索完成 ArrayList实现了接口List常见的写法会把引用声明为接口List类型注意：是java.util.List,而不是java.awt.List 泛型Generic不指定泛型的容器，可以存放任何类型的元素指定了泛型的容器，只能存放指定类型的元素以及其子类 123456789101112public Item()&#123; &#125;//提供一个初始化name的构造方法public Item(String name)&#123; this.name = name;&#125;public void effect()&#123; System.out.println(&quot;效果&quot;);&#125; 声明容器的时候，就指定了这种容器，只能放Item，放其他的就会出错 1List&lt;Item&gt; genericheros = new ArrayList&lt;&gt;(); 当然 泛型也远远不止这些内容,这里仅仅说明集合的泛型 https://www.liaoxuefeng.com/wiki/1252599548343744/1265103567584000 其他乱七八糟的集合LinkedList 序列分先进先出FIFO,先进后出FILOFIFO在Java中又叫Queue 队列FILO在Java中又叫Stack 栈 LinkedList与Arraylist一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。 接下来要讲的是LinkedList的一些特别的地方 双向链表 Deque 除了实现了List接口外，LinkedList还实现了双向链表结构Deque，可以很方便的在头尾插入删除数据 12345678910111213141516171819202122232425262728293031323334353637383940414243package collection;import java.util.LinkedList;import charactor.CzrOrz;public class TestCollection &#123; public static void main(String[] args) &#123; //LinkedList是一个双向链表结构的list LinkedList&lt;CzrOrz&gt; ll =new LinkedList&lt;&gt;(); //所以可以很方便的在头部和尾部插入数据 //在最后插入新的czr ll.addLast(new CzrOrz(&quot;c1&quot;)); ll.addLast(new CzrOrz(&quot;c2&quot;)); ll.addLast(new CzrOrz(&quot;c3&quot;)); System.out.println(ll); //在最前面插入新的czr ll.addFirst(new CzrOrz(&quot;cX&quot;)); System.out.println(ll); //查看最前面的czr System.out.println(ll.getFirst()); //查看最后面的czr System.out.println(ll.getLast()); //查看不会导致czr被删除 System.out.println(ll); //取出最前面的czr System.out.println(ll.removeFirst()); //取出最后面的czr System.out.println(ll.removeLast()); //取出会导致czr被删除 System.out.println(ll); &#125;&#125; 上述代码也同时告诉了我们LinkedList的核心API如何使用,建议大家自己动手敲一遍加深印象. QueueLinkedList 除了实现了List和Deque外，还实现了Queue接口(队列)。Queue是先进先出队列 FIFO，常用方法：offer 在最后添加元素poll 取出第一个元素peek 查看第一个元素 二叉树二叉树由各种节点组成二叉树特点：每个节点都可以有左子节点，右子节点每一个节点都有一个值 12345678910package collection;public class Node &#123; // 左子节点 public Node leftNode; // 右子节点 public Node rightNode; // 值 public Object value;&#125; 作业:二叉树 插入排序假设通过二叉树对如下10个随机数进行排序67,7,30,73,10,0,78,81,10,74排序的第一个步骤是把数据插入到该二叉树中插入基本逻辑是，小、相同的放左边，大的放右边\\1. 67 放在根节点\\2. 7 比 67小，放在67的左节点\\3. 30 比67 小，找到67的左节点7，30比7大，就放在7的右节点\\4. 73 比67大， 放在67的右节点\\5. 10 比 67小，找到67的左节点7，10比7大，找到7的右节点30，10比30小，放在30的左节点。……\\9. 10比67小，找到67的左节点7，10比7大，找到7的右节点30，10比30小，找到30的左节点10，10和10一样大，放在左边 做完再看code哦: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package collection;public class Node &#123; // 左子节点 public Node leftNode; // 右子节点 public Node rightNode; // 值 public Object value; // 插入 数据 public void add(Object v) &#123; // 如果当前节点没有值，就把数据放在当前节点上 if (null == value) value = v; // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系 else &#123; // 新增的值，比当前值小或者相同 if ((Integer) v -((Integer)value) &lt;= 0) &#123; if (null == leftNode) leftNode = new Node(); leftNode.add(v); &#125; // 新增的值，比当前值大 else &#123; if (null == rightNode) rightNode = new Node(); rightNode.add(v); &#125; &#125; &#125; public static void main(String[] args) &#123; int randoms[] = new int[] &#123; 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 &#125;; Node roots = new Node(); for (int number : randoms) &#123; roots.add(number); &#125; &#125;&#125; 遍历二叉树的遍历分左序，中序，右序左序即： 中间的数遍历后放在左边中序即： 中间的数遍历后放在中间右序即： 中间的数遍历后放在右边 其实就是根节点和左右子树的遍历顺序不同 END好家伙今天已经写很长了 大家也劳逸结合 把以上内容掌握即可~~~","categories":[],"tags":[]},{"title":"JavaSe-02","slug":"后端开发前你需要了解的JavaSe知识-02","date":"2021-01-13T15:27:43.224Z","updated":"2021-01-13T15:28:42.973Z","comments":true,"path":"2021/01/13/后端开发前你需要了解的JavaSe知识-02/","link":"","permalink":"http://example.com/2021/01/13/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84JavaSe%E7%9F%A5%E8%AF%86-02/","excerpt":"","text":"后端开发前你需要了解的JavaSe知识-02 数字与字符串封装类所有的基本类型，都有对应的类类型比如int对应的类是Integer这种类就叫做封装类 123456789101112131415package digit;public class TestNumber &#123; public static void main(String[] args) &#123; int i = 5; //把一个基本类型的变量,转换为Integer对象 Integer it = new Integer(i); //把一个Integer对象，转换为一个基本类型的int int i2 = it.intValue(); &#125;&#125; 数字封装类有Byte,Short,Integer,Long,Float,Double这些类都是抽象类Number的子类 12345678910111213package digit;public class TestNumber &#123; public static void main(String[] args) &#123; int i = 5; Integer it = new Integer(i); //Integer是Number的子类，所以打印true System.out.println(it instanceof Number); &#125;&#125; 自动装箱不需要调用构造方法，通过=符号**自动**把 基本类型 转换为 类类型 就叫装箱 123456789101112131415161718package digit;public class TestNumber &#123; public static void main(String[] args) &#123; int i = 5; //基本类型转换成封装类型 Integer it = new Integer(i); //自动转换就叫装箱 Integer it2 = i; &#125;&#125; 自动拆箱1234567891011121314151617181920package digit;public class TestNumber &#123; public static void main(String[] args) &#123; int i = 5; Integer it = new Integer(i); //封装类型转换成基本类型 int i2 = it.intValue(); //自动转换就叫拆箱 int i3 = it; &#125;&#125; STRINGBUFFERstringBuffer是可变长度的字符串 keyWord: append delete insert reverse length capacity 上述关键字可自行查询如何使用 数字与字符串内容还有很多,就是因为太多了全部罗列会显得很冗杂,所以给大家列个提纲,哪里不会查哪里即可~ 字符串转换 数学方法 格式化输出 如何操作字符串(一些API) 比较字符串 日期类开发中也经常会与时间日期打交道 比如我现在写这篇文章是 2021年1月13日18:27:19 如何使用代码获得现在的时间(当然,不止于现在的时间) 显得同样重要,于是,就有了日期类 Date 时间原点的概念所有的数据类型，无论是整数，布尔，浮点数还是字符串，最后都需要以数字的形式表现出来。 日期类型也不例外，换句话说，一个日期，比如2020年10月1日，在计算机里，会用一个数字来代替。 那么最特殊的一个数字，就是零. 零这个数字，就代表Java中的时间原点，其对应的日期是1970年1月1日 8点0分0秒 。 (为什么是8点，因为中国的太平洋时区是UTC-8，刚好和格林威治时间差8个小时) 为什么对应1970年呢？ 因为1969年发布了第一个 UNIX 版本：AT&amp;T，综合考虑，当时就把1970年当做了时间原点。 所有的日期，都是以为这个0点为基准，每过一毫秒，就+1。 getTimegetTime() 得到一个long型的整数这个整数代表 从1970.1.1 08:00:00:000 开始 每经历一毫秒，增加1直接打印对象，会看到 “Tue Jan 13 09:51:48 CST 2021” 这样的格式，可读性比较差，为了获得“2021/1/13 09:51:48”这样的格式 可以使用SimpleDateFormat这个类. keyWord:format parse 作业: 1.日期转字符串y 代表年 M 代表月 d 代表日 H 代表24进制的小时 h 代表12进制的小时 m 代表分钟 s 代表秒 S 代表毫秒 要求可以获得当前时间,并且通过以下语句输出正确的格式化后的日期: 1System.out.println(&quot;当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: &quot;+str); 2.日期格式化完成作业1后,你就可以获得格式化的日期,现在: 准备一个长度是9的日期数组使用1970年-2000年之间的随机日期初始化该数组按照这些日期的时间进行升序排序要求输出正切的升序排序的LIst 异常导致程序的正常流程被中断的事件，叫做异常 异常处理常见手段： try catch finally throws 特别记录一下多异常捕捉方法 虽然开发中不常用 但是可以当成学习 package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class TestException { 123456789101112131415161718public static void main(String[] args) &#123; File f = new File(&quot;d:/LOL.exe&quot;); try &#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date d = sdf.parse(&quot;2016-06-03&quot;); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); &#125; catch (ParseException e) &#123; System.out.println(&quot;日期格式解析错误&quot;); e.printStackTrace(); &#125;&#125; } finally无论是否出现异常，finally中的代码都会被执行 12345678910111213141516171819202122232425262728293031package exception;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;public class TestException &#123; public static void main(String[] args) &#123; File f= new File(&quot;d:/LOL.exe&quot;); try&#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); &#125; catch(FileNotFoundException e)&#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); &#125; finally&#123; System.out.println(&quot;无论文件是否存在， 都会执行的代码&quot;); &#125; &#125;&#125; Throwable这一个大家查查资料即可 自定义异常贴一下廖雪峰大佬的总结文章 关于IO这部分的重要性主要看项目的侧重点了…比如极简主义这个项目就是可以将WORD转成PPT的,当然现在很多开源的工具已经做了很好的简化,让一些看起来复杂的工作变得相当简单,所以在这里暂时不展开IO部分(也是因为内容较多)大家可以自己学习 集合框架首先先说明数组的局限性: 如果要存放多个对象，可以使用数组，但是数组有局限性比如 声明长度是10的数组不用的数组就浪费了超过10的个数，又放不下 为了解决数组的局限性，引入容器类的概念。 最常见的容器类就是ArrayList“capacity”会随着对象的增加，自动增长只需要不断往容器里增加数据即可，不用担心会出现数组的边界问题。 集合框架内容很重要,打算放到明天看看可不可以一次性讲完. END虽然有些内容我略过了 但是我都把一些网站和大家需要自己动手查的内容贴了出来 一定要自己查一查哦~","categories":[],"tags":[]},{"title":"JavaSe-01","slug":"后端开发前你需要了解的JavaSe知识-01","date":"2021-01-12T06:58:46.743Z","updated":"2021-01-12T07:02:40.065Z","comments":true,"path":"2021/01/12/后端开发前你需要了解的JavaSe知识-01/","link":"","permalink":"http://example.com/2021/01/12/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84JavaSe%E7%9F%A5%E8%AF%86-01/","excerpt":"","text":"后端开发前你需要了解的JavaSe知识-01首先配置JDK和下载idea 大家不要太学了,给大家推荐个视频: 面向对象的思想:1、面向对象EveryThing Is Object。面向对象是一种程序设计思想，计算机程序的设计实质上就是将现实中的一些事物的特征抽离出来描述成一些计算机事件的过程，这种抽象的过程中，我们把具体的事物封装成一个一个的整体进行描述，使被描述的对象具备一些系统性、整体性的的行为和特征，我们把这种设计思想称为面向对象。 2、面向对象与面向过程2.1、面向过程是早期的程序语言设计思想，该思想强调事物的行为细节，即程序的设计不需要封装成一个个的整体，而是将整个程序描述成一个行为，所有行为细节都按照固定方式一步一步的执行，执行程序就是执行某一行为的过程。2.2、面向对象和面向过程都是一种思想，面向对象是相对于面向过程而言的，面向过程强调的是具体的功能行为，而面向对象将功能封装进对象，强调具备了功能的对象，面向对象是基于面向过程的，但面向对象思想更接近于现实场景。 示例代码: 1234567891011121314151617package wizzWinterCamp;/** * @author liqiqi_tql * @date 2021/1/12 -13:08 */public class man &#123;// 名字 String name;// 血量 float hp;// 身高 float stature; void study()&#123; System.out.println(&quot;冬令营疯狂学习中...&quot;); &#125;&#125; 在上面,man就是这个类的名称,name,hp,stature是类的属性,属性可以是基本类型,例如int,float…也可以是类类型,例如String. man在上面有一个自己的方法,就是study. 关于变量是什么变量的定义是： 用来命名一个数据的标识符 int year =2002 //year就是一个变量,表示2002这个值 这八种基本类型分别是：整型 （4种）字符型 （1种）浮点型 （2种）布尔型（1种） 具体Google. 一些小例子: 123456789101112131415161718package wizzwintercamp/** * @author liqiqi_tql * @date 2021/1/12 -13:27 */public class HelloWorld&#123; public static void main(String[] args)&#123; byte b = 1; short s = 200; int i = 300; long l = 400; /*如果试图给byte类型的变量赋予超出其范围的值，就会产生编译错误 同理 char类型只能存一位字符,两位则会造成编译错误*/ byte b2 = 200; &#125;&#125; STRINGString类型其实并不是基本类型，但是它是如此广泛的被使用，常常被误以为是一种基本类型。String类型是Immutable的，一旦创建就不能够被改变. 一些变量的命名,希望大家可以使用驼峰命名的方式,这样非常简单易懂. 变量的作用域当一个变量被声明在类下面变量就叫做字段 或者属性、成员变量、Field比如变量i,就是一个属性。那么从第2行这个变量声明的位置开始，整个类都可以访问得到所以其作用域就是从其声明的位置开始的整个类 就比如上面man这个类 我们定义了一些属性之后直接可以写几个方法来访问他们: 123public void myHp()&#123; System.out.println(&quot;我还有多少血啊~~~ &quot;+hp); //myHp里可以访问hp&#125; 方法的参数: 123public void paramMethod(int i)&#123; System.out.println(&quot;我随便输了个i~~~ &quot;+i); &#x2F;&#x2F;这个方法可以访问i,但是出了这个方法的作用域就不能访问了.&#125; FINAL:final 修饰一个变量，有很多种说法，比如不能改变等等准确的描述是 当一个变量被final修饰的时候，该变量只有一次赋值的机会 123final int i&#x3D;5;i&#x3D;4;&#x2F;&#x2F;这里再赋值会编译错误 控制流程:总之大家学C的时候使用if switch while for continue break 肯定十分熟练,这里再把C的形式换成JAVA的即可. po一发switch的 太久没用: 12345678910111213141516171819202122232425switch(day)&#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期天&quot;); break;default: System.out.println(&quot;这个是什么鬼？&quot;); &#125; 接口:这一部分在开发阶段就很重要了,大家没事的时候想管理好项目的一些方法的时候都会写很多接口来实现. 我们经常听到:”啊 我那个项目用了#{某大厂}的接口” 这种话 都会觉得不明觉厉 然后开始orz那个人 但是其实那个接口应该更准确来讲是叫API 这部分要讲的接口是interface 接口就像是一种约定，我们约定某个人是卑微后端，那么他们就一定只能是后端。 123456package charactor;public interface Backender &#123; //只能写后端了 public void onlyBE();&#125; 然后当一个类去实现这个接口的时候,就可以override这个接口的方法 12345678910package charactor;public class Yxr implements Backender&#123;//最好加上这个注解,表示实现了这个接口里面的某个方法 @Override public void onlyBE() &#123; System.out.println(&quot;这个人只会后端&quot;); &#125;&#125; 当然,现实生活中往往有大佬可以做到fullStack,我们为之就有一位@czr 大家可以去发现哪一个人是他然后去和他贴贴和他交流他怎么这么大佬. 123456package charactor;public interface Frontender &#123; //只能写前端了 public void onlyFE();&#125; 当我们都是czr时,我们的技能树就可以这样点: 12345678910111213package charactor;public class czr implements Backender,Frontender&#123;//最好加上这个注解,表示实现了这个接口里面的某个方法 @Override public void onlyBE() &#123; System.out.println(&quot;这个人只会后端&quot;); &#125; @Override public void onlyBE() &#123; System.out.println(&quot;这个人只会前端&quot;); &#125;&#125; 但是现实是残酷的,czr已经开始广泛涉猎图形学以及算法相关的知识了…快去和他贴贴 多态操作符的多态+ 可以作为算数运算，也可以作为字符串连接 类的多态父类引用指向子类对象 面试的一个考点:向下转型和向上转型老知乎人推荐你们看一篇: 关于转型 总结： 1。父类引用指向子类对象，而子类引用不能指向父类对象。 2。把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转换。 如：Father f1 = new Son(); 3。把指向子类对象的父类引用赋给子类引用叫向下转型(downcasting)，要强制转换。 如：f1 就是一个指向子类对象的父类引用。把f1赋给子类引用s1即 Son s1 = (Son)f1； 其中f1前面的(Son)必须加上，进行强制转换。 一些比较折磨人的点:123456789101112131415public class HelloWord &#123; *&#x2F;&#x2F;执行结果是？* public static void main(String[] args)&#123; short a &#x3D;1; ​ a &#x3D; a+1; ​ System.out.print(a); &#125; &#125; 以上code会编译错误,因为第9行 a=a+1 1是整形类型 123456789101112131415public class HelloWord &#123; public static void main(String[] args)&#123; short a =1; short b =1; short c = a+b; System.out.print(c); &#125; &#125; 以上code依旧会报错 精度小于int的数值运算的时候都回被自动转换为int后进行计算; 正确写法: 12345678910111213public class HelloWord &#123; public static void main(String[] args)&#123; short a =1; short b =1; short c = (short)(a+b); System.out.print(c); &#125; &#125; 关于更多类型转换,可以看看这篇文章 ENDse部分的01就写到这里,相信再没几个篇章就可以去看看spring家族了. se这部分身为基础还是很重要的,写一写这些知识对大家有用的话就很不错啦! web开发还需要一些网络相关的知识,学有余力的同学可以提前看看.","categories":[],"tags":[]},{"title":"2021WIZZ BE冬令营前言","slug":"为之2021后端冬令营前言","date":"2021-01-11T13:05:05.827Z","updated":"2021-01-11T14:17:20.237Z","comments":true,"path":"2021/01/11/为之2021后端冬令营前言/","link":"","permalink":"http://example.com/2021/01/11/%E4%B8%BA%E4%B9%8B2021%E5%90%8E%E7%AB%AF%E5%86%AC%E4%BB%A4%E8%90%A5%E5%89%8D%E8%A8%80/","excerpt":"","text":"update:2021.01.11 本文作于2020.12.17 期末复习摸鱼所得 首先分享一句话 “互联网时代正确使用搜索工具与否是人与动物的根本区别” 如果你觉得上面这句话好像有点道理,可以设置成你的QQ个性签名或者微信的个性签名. 为之2021冬令营–&gt;后端方向 应该是前言一样的存在前段时间浩天学长跟我说了手有没有兴趣做一做为之后端的冬令营,出于好奇以及责任感我答应了下来.正巧一是现在复习文化课没什么动力,二是自己的博客水文似乎很久没有去水一篇了,所以打算写个大致的规划. 看了一手浩天学长的2020年冬季的冬令营文章.觉得珠玉在前的同时也深感压力.(可能因为我很多不会吧) 那么2021为之冬令营的主要科普(也许这个词比较合适)是Java,Java作为目前后端主流的开发语言重要性不言而喻.所以我们选择Java也就选择了未来主流趋势.(当然2020年冬令营介绍的GO语言也是一门十分不错的语言.) Java我们学校也开设了相关的课程,但是仅仅教授了业界认为的Javase部分:即基本语法和方法等使用.从Javase到后端开发还是有一小段距离要走. 我当初学习的时候是Javase-&gt;J2ee-&gt;SpringBoot-&gt;SpringCloud-&gt;整合一些中间件…这样走的,但其实J2ee这部分说起来用处不大.算是为大家避了个坑(面试的时候如果问到相关知识还是要提前会的) 所以我觉得这次关于Java的冬令营我们应该可以把SpringBoot的一些开发知识梳理梳理,因为面向的主要对象是未来的wizzer所以就擅自认为你们暂时没有掌握相关知识好了盒盒盒. 没想到写到这里我就不知道这篇文章再该扯点啥了,所以在某些网站搜集了一些资料,贴出来大家先浏览浏览. JAVA的特点- 简单性 Java的设计目的是让专业程序员觉得既易学由好用。如果你已经学习过C++了的话，那学习Java将不费吹灰之力，Java对于C语言中出现的许多容易混淆概念的东西要么弃置不用，要么以一种更清楚、更易理解的方式出现。 - 面向对象性 尽管Java是在C++的基础上开发出来的，当Java并没被设计成兼容其他语言源代码的程序语言。Java语言可以更直接、更易用、更实际地接近对象。 - 分布式 Java是为Internet的分布式环境而设计的，因此它可以处理TCP/IP协议。 - 安全 Java在网络应用程序为用户的计算提供了一道防火墙（firewall），消除了用户的安全顾虑。Java实现这中保护功能的方法是通过将Java程序限制在Java运行环境中，不允许它访问计算机的其他部分。 - 多线程 Java设计的目的之一就是满足人们创建交互式网上程序的需要，为此，Java支持多线程编程，用Java编写的应用程序可以同时执行多个任务。Java运行时，系统在多线程同步方面具有成熟的解决方案，使得用户能够创建出运行平稳的交互式西系统。Java多线程机制非常好用，因此用户只需关注程序细节，而不用担心后台的多任务系统。 - 动态 Java程序带有多种运行的类型信息，用于在运行是校验和解决对象访问问题。 - 解释型 Java是一种解释型语言，通过把程序编为Java字节码这样一个中间过程，产生跨平台运行的程序，字节码可以在提供Java虚拟机（JVM）的任何一种系统中被解释执行。 - 高性能 Java可以在性能极低的CPU上顺利运行。Java字节码经过仔细设计，因而使用JIT编译技术能很容易地将字节码直接转换成高性能的本机代码，因而”高效且跨品台“对于Java来说不再是矛盾。 - 健壮 Java通过替用户管理内存分配和释放，可以从根本上消除传统编程环境下内存管理困难和乏味的任务。 - 结构中立和可移植性 Java设计者考虑的主要问题是程序代码的持久性和可移植性。程序员面临的一个主要问题是，不能保证今天编写的程序明天仍然能在同一台机器上顺利运行。操作系统升级、处理器升级以及核心系统资源的变化，都可能导致程序无法继续运行 总结总而言之,看了上面的Java的特点,我觉得我也有很多对Java还未了解的地方,希望在可以向大家传送一些知识的同时自己也能有所感悟,互相进步. 以及这篇文章真的只是单纯的前言,大家可以先看一看Java的语法,这里指的是萌新(不是大佬装的假萌新,是真的萌新的萌新). 13号会陆续开始发资料即使现在根本还没准备 到时候就可以在知道Java语法之后更加得心应手! (好像大一下期会学习,希望大家选的不是python) 贴一下我的GitHub以及个人博客的地址,欢迎交流学习. https://github.com/baijianruoliorz https://yangxiangrui.site/","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-01-11T13:00:12.506Z","updated":"2021-01-11T13:00:12.507Z","comments":true,"path":"2021/01/11/hello-world/","link":"","permalink":"http://example.com/2021/01/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}